<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Minecraft Texture Recolor</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', 'Helvetica Neue', sans-serif;
      background: #0b0b0c;
      color: #f4f4f4;
      display: flex;
      justify-content: center;
      align-items: start;
      height: 100vh;
      padding: 2rem;
    }

    .container {
      background: #111;
      padding: 2rem;
      border-radius: 20px;
      box-shadow: 0 0 60px rgba(255, 255, 255, 0.07);
      max-width: 700px;
      width: 100%;
    }

    h1 {
      text-align: center;
      font-weight: 600;
      font-size: 2rem;
      margin-bottom: 2rem;
      text-transform: uppercase;
      letter-spacing: 1.5px;
    }

    label {
      display: block;
      margin: 1.2rem 0 0.4rem;
      color: #bbb;
      font-weight: 500;
    }

    input[type="file"],
    input[type="color"],
    select,
    button {
      width: 100%;
      padding: 0.75rem;
      border-radius: 14px;
      border: none;
      margin-bottom: 1rem;
      background: #1a1a1a;
      color: white;
    }

    input[type="checkbox"] {
      margin-right: 0.5rem;
      transform: scale(1.2);
      accent-color: #e50914;
    }

    .checkbox-group label {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      cursor: pointer;
    }

    button {
      background-color: #e50914;
      color: white;
      font-weight: bold;
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: #b20710;
    }

    #previewContainer {
      margin-top: 2rem;
    }

    #previewGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
      gap: 10px;
      margin-top: 1rem;
    }

    .preview-image {
      width: 64px;
      height: 64px;
      border: 2px solid #444;
      border-radius: 10px;
      image-rendering: pixelated;
      position: relative;
    }

    .preview-image:hover {
      outline: 2px solid #e50914;
      cursor: pointer;
    }

    .remove-toggle {
      position: absolute;
      top: 2px;
      right: 2px;
      background: #1a1a1a;
      color: #e50914;
      border: 1px solid #e50914;
      border-radius: 50%;
      font-size: 0.8rem;
      padding: 1px 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .remove-toggle:hover {
      background: #e50914;
      color: white;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Texture Modifier</h1>
    <form id="textureForm">
      <label for="packInput">Resource Pack (.zip):</label>
      <input type="file" id="packInput" accept=".zip" required />

      <label for="huePicker">Primary Color:</label>
      <input type="color" id="huePicker" value="#ff00ff" />

      <label for="secondaryColor">Secondary Color (for gradient):</label>
      <input type="color" id="secondaryColor" value="#00ffff" />

      <label for="colorMode">Color Mode:</label>
      <select id="colorMode">
        <option value="hue">Hue Shift</option>
        <option value="tint">Tint</option>
        <option value="gradient">Gradient Map</option>
      </select>

      <div class="checkbox-group">
        <label><input type="checkbox" id="includeBlocks" checked /> Include Blocks</label>
        <label><input type="checkbox" id="includeItems" checked /> Include Items/Tools</label>
        <label><input type="checkbox" id="includeGui" /> Include GUI Textures</label>
      </div>

      <button type="submit">Apply</button>
    </form>

    <div id="status">Status: Waiting...</div>
    <progress id="progressBar" value="0" max="100" style="width: 100%; margin-top: 10px;"></progress>
    <a id="downloadLink" style="display:none; margin-top: 1rem;" download="ModifiedPack.zip">Download</a>

    <div id="previewContainer">
      <h3>Preview</h3>
      <div id="previewGrid"></div>
    </div>
  </div>

  <script>
    const includeBlocks = () => document.getElementById('includeBlocks').checked;
    const includeItems = () => document.getElementById('includeItems').checked;
    const includeGui = () => document.getElementById('includeGui').checked;
    document.getElementById("textureForm").addEventListener("submit", async (e) => {
  e.preventDefault();

  const packFile = document.getElementById("packInput").files[0];
  if (!packFile) return;
  
  // Get color inputs and mode
  const primaryHex = document.getElementById("huePicker").value;
  const secondaryHex = document.getElementById("secondaryColor").value;
  const mode = document.getElementById("colorMode").value;
  
  // Convert primary color to a value usable by our algorithm.
  // For hue mode we extract the hue from the primary color.
  const [targetHue] = rgbToHsl(...hexToRgb(primaryHex));
  
  // Load the zip file
  const zip = await JSZip.loadAsync(packFile);
  const newZip = new JSZip();
  
  // Helper functions to determine file type
  function isBlockTexture(path) {
    // Assuming block textures are stored in "textures/block/"
    return path.includes("textures/block/");
  }
  
  function isItemTexture(path) {
    // Assuming item textures are stored in "textures/item/"
    return path.includes("textures/item/");
  }
  
  function isGuiTexture(path) {
    // Check for common GUI texture paths
    return path.includes("textures/gui") || path.includes("atlas") || path.includes("container");
  }
  
  // Iterate over each file in the pack
  const filePaths = Object.keys(zip.files);
  const previewGrid = document.getElementById("previewGrid");
  previewGrid.innerHTML = "";
  let processedCount = 0;
  
  for (const path of filePaths) {
    const file = zip.files[path];
    // Copy non-PNG files as-is
    if (!path.endsWith(".png")) {
      newZip.file(path, await file.async("arraybuffer"));
      continue;
    }
    
    // Determine file type and check against UI selections
    const isBlock = isBlockTexture(path);
    const isItem = isItemTexture(path);
    const isGui = isGuiTexture(path);
    
    // If file is PNG but should not be processed per the checkboxes, simply copy it.
    if ((isBlock && !document.getElementById("includeBlocks").checked) ||
        (isItem && !document.getElementById("includeItems").checked) ||
        (isGui && !document.getElementById("includeGui").checked)) {
      newZip.file(path, await file.async("arraybuffer"));
      continue;
    }
    
    // Process the image file by recoloring it using our algorithm.
    const blob = await file.async("blob");
    const modifiedBlob = await shiftColor(blob, targetHue, primaryHex, secondaryHex, mode);
    
    // Add preview element
    const imgURL = URL.createObjectURL(modifiedBlob);
    const wrapper = document.createElement("div");
    wrapper.style.position = "relative";
    const img = document.createElement("img");
    img.src = imgURL;
    img.alt = path.split("/").pop();
    img.title = path;
    img.className = "preview-image";
    wrapper.appendChild(img);
    
    // Add removal button
    const removeBtn = document.createElement("button");
    removeBtn.textContent = "✕";
    removeBtn.className = "remove-toggle";
    removeBtn.onclick = () => {
      wrapper.remove();
      // Remove from newZip as well – here we simply mark it removed
      newZip.remove(path);
    };
    wrapper.appendChild(removeBtn);
    previewGrid.appendChild(wrapper);
    
    // Add the modified file to the new zip
    newZip.file(path, modifiedBlob);
    processedCount++;
    document.getElementById("status").textContent = `Processed ${processedCount} of ${filePaths.length}`;
  }
  
  // Generate new zip and provide download link
  const resultBlob = await newZip.generateAsync({ type: "blob" });
  const downloadLink = document.getElementById("downloadLink");
  downloadLink.href = URL.createObjectURL(resultBlob);
  downloadLink.style.display = "block";
  document.getElementById("status").textContent = "Done! Ready to download.";
});

// --- Recoloring functions ---

// Converts a hex color string to an [r, g, b] array.
function hexToRgb(hex) {
  const bigint = parseInt(hex.slice(1), 16);
  return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
}

// Converts RGB to HSL and returns [h, s, l]
function rgbToHsl(r, g, b) {
  r /= 255; g /= 255; b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;
  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch(max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }
  return [h * 360, s, l];
}

// Converts HSL to RGB and returns [r, g, b]
function hslToRgb(h, s, l) {
  h /= 360;
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return [r * 255, g * 255, b * 255];
}

// Recoloring function that applies the selected mode
async function shiftColor(blob, targetHue, primaryHex, secondaryHex, mode) {
  return new Promise((resolve) => {
    const img = new Image();
    img.src = URL.createObjectURL(blob);
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const primaryRGB = hexToRgb(primaryHex);
      const secondaryRGB = hexToRgb(secondaryHex);
      
      for (let i = 0; i < data.length; i += 4) {
        const alpha = data[i + 3];
        if (alpha < 10) continue;
        const r = data[i], g = data[i + 1], b = data[i + 2];
        if (mode === "hue") {
          // Convert to HSL, then replace hue with targetHue
          const [h, s, l] = rgbToHsl(r, g, b);
          const [nr, ng, nb] = hslToRgb(targetHue, s, l);
          data[i] = nr; data[i + 1] = ng; data[i + 2] = nb;
        } else if (mode === "tint") {
          // Average the original color with the primary color
          data[i] = (r + primaryRGB[0]) / 2;
          data[i + 1] = (g + primaryRGB[1]) / 2;
          data[i + 2] = (b + primaryRGB[2]) / 2;
        } else if (mode === "gradient") {
          // Use brightness to interpolate between primary and secondary colors
          const brightness = (r + g + b) / (3 * 255);
          data[i] = primaryRGB[0] * (1 - brightness) + secondaryRGB[0] * brightness;
          data[i + 1] = primaryRGB[1] * (1 - brightness) + secondaryRGB[1] * brightness;
          data[i + 2] = primaryRGB[2] * (1 - brightness) + secondaryRGB[2] * brightness;
        }
      }
      ctx.putImageData(imageData, 0, 0);
      canvas.toBlob(resolve, "image/png");
    };
  });
}

  </script>
</body>
</html>
