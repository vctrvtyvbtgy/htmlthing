<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Minecraft Texture Pack Reforged</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
</head>
<body>
  <div class="main-container">
    <div class="header">
      <h1>Texture Pack Reforged</h1>
      <p class="subtitle">Advanced Minecraft Resource Pack Editor</p>
    </div>
    
    <div class="content-container">
      <form id="textureForm">
        <div class="form-group file-upload-container">
          <label for="packInput" class="file-upload-label">
            <span class="icon">üì¶</span>
            <span>Select Resource Pack (.zip)</span>
          </label>
          <input type="file" id="packInput" accept=".zip" required />
          <span class="selected-file" id="selectedFileName">No file selected</span>
        </div>

        <div class="options-container">
          <div class="option-card">
            <h3>Color Transformation</h3>
            
            <div class="form-group">
              <label for="huePicker">Target Hue:</label>
              <input type="color" id="huePicker" value="#ff0000" />
            </div>
            
            <div class="form-group">
              <label for="saturationSlider">Saturation Adjustment:</label>
              <div class="slider-container">
                <input type="range" id="saturationSlider" min="-100" max="100" value="0" />
                <span id="saturationValue">0%</span>
              </div>
            </div>
            
            <div class="form-group">
              <label for="brightnessSlider">Brightness Adjustment:</label>
              <div class="slider-container">
                <input type="range" id="brightnessSlider" min="-100" max="100" value="0" />
                <span id="brightnessValue">0%</span>
              </div>
            </div>
            
            <div class="form-group">
              <label for="contrastSlider">Contrast:</label>
              <div class="slider-container">
                <input type="range" id="contrastSlider" min="-50" max="100" value="0" />
                <span id="contrastValue">0%</span>
              </div>
            </div>
            
            <div class="form-group">
              <label for="vibrance">Vibrance:</label>
              <div class="slider-container">
                <input type="range" id="vibranceSlider" min="0" max="100" value="20" />
                <span id="vibranceValue">20%</span>
              </div>
            </div>
          </div>
          
          <div class="option-card">
            <h3>Advanced Options</h3>
            
            <div class="form-group">
              <label for="preservationSlider">Preserve Original Colors:</label>
              <div class="slider-container">
                <input type="range" id="preservationSlider" min="0" max="100" value="20" />
                <span id="preservationValue">20%</span>
              </div>
            </div>
            
            <div class="form-group">
              <label for="colorShiftMode">Color Shift Mode:</label>
              <select id="colorShiftMode" class="styled-select">
                <option value="standard">Standard (Full Recolor)</option>
                <option value="harmonize">Harmonize (Keep Character)</option>
                <option value="accent">Accent Only</option>
                <option value="tint">Tint Overlay</option>
              </select>
            </div>
            
            <div class="form-group">
              <label for="colorThreshold">Color Detection Threshold:</label>
              <div class="slider-container">
                <input type="range" id="colorThreshold" min="0" max="100" value="15" />
                <span id="thresholdValue">15%</span>
              </div>
            </div>
            
            <div class="form-group">
              <label for="noiselevel">Noise Reduction:</label>
              <div class="slider-container">
                <input type="range" id="noiseLevel" min="0" max="100" value="10" />
                <span id="noiseValue">10%</span>
              </div>
            </div>
          </div>
          
          <div class="option-card checkbox-card">
            <h3>Apply To</h3>
            <div class="checkbox-section">
              <div class="checkbox-category">
                <h4>Items</h4>
                <div class="checkbox-group">
                  <label><input type="checkbox" id="modifyItems" checked> Basic Items</label>
                  <label><input type="checkbox" id="modifyFood"> Food</label>
                  <label><input type="checkbox" id="modifyBlocks"> Block Items</label>
                  <label><input type="checkbox" id="modifyOres"> Ores & Minerals</label>
                </div>
              </div>
              
              <div class="checkbox-category">
                <h4>Equipment</h4>
                <div class="checkbox-group">
                  <label><input type="checkbox" id="modifySwords"> Swords</label>
                  <label><input type="checkbox" id="modifyTools"> Tools</label>
                  <label><input type="checkbox" id="modifyBows"> Bows & Crossbows</label>
                  <label><input type="checkbox" id="modifyArmor"> Armor</label>
                  <label><input type="checkbox" id="modifyShields"> Shields</label>
                </div>
              </div>
              
              <div class="checkbox-category">
                <h4>Interface</h4>
                <div class="checkbox-group">
                  <label><input type="checkbox" id="modifyUI"> UI Elements</label>
                  <label><input type="checkbox" id="modifyHotbar"> Hotbar</label>
                  <label><input type="checkbox" id="modifyInventory"> Inventory</label>
                  <label><input type="checkbox" id="modifyParticles"> Particles</label>
                </div>
              </div>
              
              <div class="checkbox-category">
                <h4>Special</h4>
                <div class="checkbox-group">
                  <label><input type="checkbox" id="modifyEnchanted"> Enchanted Effects</label>
                  <label><input type="checkbox" id="modifyPotions"> Potions</label>
                  <label><input type="checkbox" id="modifyEntities"> Entity Textures</label>
                </div>
              </div>
            </div>
          </div>
          
          <div class="option-card presets-card">
            <h3>Color Presets</h3>
            <div class="color-presets">
              <button type="button" class="preset-button" data-color="#ff0000" style="background-color: #ff0000;"></button>
              <button type="button" class="preset-button" data-color="#00ff00" style="background-color: #00ff00;"></button>
              <button type="button" class="preset-button" data-color="#0000ff" style="background-color: #0000ff;"></button>
              <button type="button" class="preset-button" data-color="#ffff00" style="background-color: #ffff00;"></button>
              <button type="button" class="preset-button" data-color="#ff00ff" style="background-color: #ff00ff;"></button>
              <button type="button" class="preset-button" data-color="#00ffff" style="background-color: #00ffff;"></button>
              <button type="button" class="preset-button" data-color="#ff6600" style="background-color: #ff6600;"></button>
              <button type="button" class="preset-button" data-color="#9900ff" style="background-color: #9900ff;"></button>
            </div>
          </div>
        </div>

        <button type="submit" class="action-button">
          <span class="button-icon">‚ö°</span>
          <span>Process Pack</span>
        </button>
      </form>

      <div class="progress-section">
        <div class="status-container">
          <div id="status">Ready to transform your textures</div>
          <div class="status-icon" id="statusIcon">‚è≥</div>
        </div>
        <div class="progress-container">
          <progress id="progressBar" value="0" max="100"></progress>
          <span id="progressPercentage">0%</span>
        </div>
        <a id="downloadLink" class="action-button download-button" download="ReforgedPack.zip">
          <span class="button-icon">‚¨áÔ∏è</span>
          <span>Download Modified Pack</span>
        </a>
      </div>

      <div id="previewContainer">
        <h3>Live Preview</h3>
        <div class="preview-controls">
          <div class="preview-tabs">
            <button class="tab-button active" data-tab="items">Items</button>
            <button class="tab-button" data-tab="tools">Equipment</button>
            <button class="tab-button" data-tab="ui">Interface</button>
            <button class="tab-button" data-tab="special">Special</button>
          </div>
          <div class="preview-zoom">
            <button id="zoomOut" class="zoom-button">-</button>
            <span id="zoomLevel">100%</span>
            <button id="zoomIn" class="zoom-button">+</button>
          </div>
        </div>
        
        <div class="preview-comparison">
          <div class="comparison-option">
            <input type="checkbox" id="sideBySide" checked>
            <label for="sideBySide">Side by Side View</label>
          </div>
        </div>
        
        <div class="preview-wrapper">
          <div class="preview-panel active" id="items-panel">
            <div class="preview-grid" id="itemsPreviewGrid"></div>
          </div>
          <div class="preview-panel" id="tools-panel">
            <div class="preview-grid" id="toolsPreviewGrid"></div>
          </div>
          <div class="preview-panel" id="ui-panel">
            <div class="preview-grid" id="uiPreviewGrid"></div>
          </div>
          <div class="preview-panel" id="special-panel">
            <div class="preview-grid" id="specialPreviewGrid"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // DOM References
    const form = document.getElementById("textureForm");
    const status = document.getElementById("status");
    const statusIcon = document.getElementById("statusIcon");
    const progressBar = document.getElementById("progressBar");
    const progressPercentage = document.getElementById("progressPercentage");
    const downloadLink = document.getElementById("downloadLink");
    const packInput = document.getElementById("packInput");
    const selectedFileName = document.getElementById("selectedFileName");
    
    // Color adjustment sliders
    const huePicker = document.getElementById("huePicker");
    const saturationSlider = document.getElementById("saturationSlider");
    const brightnessSlider = document.getElementById("brightnessSlider");
    const contrastSlider = document.getElementById("contrastSlider");
    const vibranceSlider = document.getElementById("vibranceSlider");
    const preservationSlider = document.getElementById("preservationSlider");
    const colorThreshold = document.getElementById("colorThreshold");
    const noiseLevel = document.getElementById("noiseLevel");
    const colorShiftMode = document.getElementById("colorShiftMode");
    
    // UI labels
    const saturationValue = document.getElementById("saturationValue");
    const brightnessValue = document.getElementById("brightnessValue");
    const contrastValue = document.getElementById("contrastValue");
    const vibranceValue = document.getElementById("vibranceValue");
    const preservationValue = document.getElementById("preservationValue");
    const thresholdValue = document.getElementById("thresholdValue");
    const noiseValue = document.getElementById("noiseValue");
    
    // Preview grid references
    const itemsPreviewGrid = document.getElementById("itemsPreviewGrid");
    const toolsPreviewGrid = document.getElementById("toolsPreviewGrid");
    const uiPreviewGrid = document.getElementById("uiPreviewGrid");
    const specialPreviewGrid = document.getElementById("specialPreviewGrid");
    
    // Preview zoom controls
    const zoomInBtn = document.getElementById("zoomIn");
    const zoomOutBtn = document.getElementById("zoomOut");
    const zoomLevelDisplay = document.getElementById("zoomLevel");
    let currentZoom = 100;
    const previewGrids = document.querySelectorAll(".preview-grid");
    
    // Side by side comparison
    const sideBySideCheckbox = document.getElementById("sideBySide");
    
    // Color preset buttons
    const presetButtons = document.querySelectorAll(".preset-button");
    
    // Initialize UI elements
    downloadLink.style.display = "none";
    
    // File selection display
    packInput.addEventListener("change", function() {
      if (this.files && this.files[0]) {
        selectedFileName.textContent = this.files[0].name;
        // Reset preview and progress
        resetUI();
      } else {
        selectedFileName.textContent = "No file selected";
      }
    });
    
    // Reset UI state
    function resetUI() {
      itemsPreviewGrid.innerHTML = "";
      toolsPreviewGrid.innerHTML = "";
      uiPreviewGrid.innerHTML = "";
      specialPreviewGrid.innerHTML = "";
      progressBar.value = 0;
      progressPercentage.textContent = "0%";
      downloadLink.style.display = "none";
      status.textContent = "Ready to transform your textures";
      statusIcon.textContent = "‚è≥";
    }
    
    // Tab functionality
    const tabButtons = document.querySelectorAll('.tab-button');
    const previewPanels = document.querySelectorAll('.preview-panel');
    
    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        // Remove active class from all buttons and panels
        tabButtons.forEach(btn => btn.classList.remove('active'));
        previewPanels.forEach(panel => panel.classList.remove('active'));
        
        // Add active class to clicked button and corresponding panel
        button.classList.add('active');
        document.getElementById(`${button.dataset.tab}-panel`).classList.add('active');
      });
    });
    
    // Color preset buttons
    presetButtons.forEach(button => {
      button.addEventListener('click', () => {
        huePicker.value = button.dataset.color;
      });
    });
    
    // Sliders and values
    saturationSlider.addEventListener('input', () => {
      saturationValue.textContent = `${saturationSlider.value}%`;
    });
    
    brightnessSlider.addEventListener('input', () => {
      brightnessValue.textContent = `${brightnessSlider.value}%`;
    });
    
    contrastSlider.addEventListener('input', () => {
      contrastValue.textContent = `${contrastSlider.value}%`;
    });
    
    vibranceSlider.addEventListener('input', () => {
      vibranceValue.textContent = `${vibranceSlider.value}%`;
    });
    
    preservationSlider.addEventListener('input', () => {
      preservationValue.textContent = `${preservationSlider.value}%`;
    });
    
    colorThreshold.addEventListener('input', () => {
      thresholdValue.textContent = `${colorThreshold.value}%`;
    });
    
    noiseLevel.addEventListener('input', () => {
      noiseValue.textContent = `${noiseLevel.value}%`;
    });
    
    // Zoom functionality
    zoomInBtn.addEventListener('click', () => {
      if (currentZoom < 400) {
        currentZoom += 25;
        updateZoom();
      }
    });
    
    zoomOutBtn.addEventListener('click', () => {
      if (currentZoom > 50) {
        currentZoom -= 25;
        updateZoom();
      }
    });
    
    function updateZoom() {
      zoomLevelDisplay.textContent = `${currentZoom}%`;
      previewGrids.forEach(grid => {
        const baseSize = 64;
        const newSize = (baseSize * currentZoom) / 100;
        const images = grid.querySelectorAll('.preview-image');
        images.forEach(img => {
          img.style.width = `${newSize}px`;
          img.style.height = `${newSize}px`;
        });
      });
    }
    
    // Side by Side view control
    sideBySideCheckbox.addEventListener('change', () => {
      document.querySelectorAll('.preview-item-container').forEach(container => {
        container.classList.toggle('side-by-side', sideBySideCheckbox.checked);
      });
    });

    // Color Transformation Functions
    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }

      return [h * 360, s, l];
    }

    function hslToRgb(h, s, l) {
      h /= 360;
      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;

        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }

      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }
    
    function rgbToLab(r, g, b) {
      // Convert RGB to XYZ
      r /= 255; g /= 255; b /= 255;
      
      // Apply gamma correction
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      
      // Convert to XYZ
      let x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      let y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      let z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      
      // Convert XYZ to Lab
      x /= 0.95047; y /= 1.0; z /= 1.08883;
      
      x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16/116);
      y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16/116);
      z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16/116);
      
      const l = (116 * y) - 16;
      const a = 500 * (x - y);
      const b_val = 200 * (y - z);
      
      return [l, a, b_val];
    }
    
    function labToRgb(l, a, b) {
      // Convert Lab to XYZ
      let y = (l + 16) / 116;
      let x = a / 500 + y;
      let z = y - b / 200;
      
      x = 0.95047 * (x * x * x > 0.008856 ? x * x * x : (x - 16/116) / 7.787);
      y = 1.0 * (y * y * y > 0.008856 ? y * y * y : (y - 16/116) / 7.787);
      z = 1.08883 * (z * z * z > 0.008856 ? z * z * z : (z - 16/116) / 7.787);
      
      // Convert XYZ to RGB
      let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      let b_val = x * 0.0557 + y * -0.2040 + z * 1.0570;
      
      // Apply gamma correction
      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1/2.4) - 0.055 : 12.92 * r;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1/2.4) - 0.055 : 12.92 * g;
      b_val = b_val > 0.0031308 ? 1.055 * Math.pow(b_val, 1/2.4) - 0.055 : 12.92 * b_val;
      
      // Clamp and convert to 0-255
      r = Math.max(0, Math.min(1, r)) * 255;
      g = Math.max(0, Math.min(1, g)) * 255;
      b_val = Math.max(0, Math.min(1, b_val)) * 255;
      
      return [Math.round(r), Math.round(g), Math.round(b_val)];
    }
    
    function adjustSaturation(s, adjustment) {
      const factor = 1 + (adjustment / 100);
      return Math.max(0, Math.min(1, s * factor));
    }
    
    function adjustBrightness(l, adjustment) {
      return Math.max(0, Math.min(1, l + (adjustment / 200)));
    }
    
    function adjustContrast(value, contrast) {
      // Apply contrast adjustment (value in range 0-1)
      const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
      return Math.max(0, Math.min(1, factor * (value - 0.5) + 0.5));
    }

    function colorDistance(rgb1, rgb2) {
      const rmean = (rgb1[0] + rgb2[0]) / 2;
      const r = rgb1[0] - rgb2[0];
      const g = rgb1[1] - rgb2[1];
      const b = rgb1[2] - rgb2[2];
      
      // Weighted distance accounting for human eye sensitivity
      return Math.sqrt((2 + rmean/256) * r * r + 4 * g * g + (2 + (255-rmean)/256) * b * b);
    }
    
    function applyVibrance(r, g, b, vibrance) {
      // Calculate grayscale value (luminance)
      const max = Math.max(r, g, b);
      const avg = (r + g + b) / 3;
      const amt = ((Math.abs(max - avg) * 2 / 255) * vibrance) / 100;
      
      // Adjust RGB values based on vibrance
      if (r !== max) r += (max - r) * amt;
      if (g !== max) g += (max - g) * amt;
      if (b !== max) b += (max - b) * amt;
      
      return [Math.round(r), Math.round(g), Math.round(b)];
    }
    
    function getPixelNoise(imageData, x, y, width) {
      // Simple noise estimation based on neighbor difference
      const idx = (y * width + x) * 4;
      let avgDiff = 0;
      
      // Check neighboring pixels
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue;
          
          const nx = x + dx;
          const ny = y + dy;
          
          if (nx >= 0 && nx < width && ny >= 0 && ny < imageData.height) {
            const nidx = (ny * width + nx) * 4;
            avgDiff += Math.abs(imageData.data[idx] - imageData.data[nidx]);
            avgDiff += Math.abs(imageData.data[idx+1] - imageData.data[nidx+1]);
            avgDiff += Math.abs(imageData.data[idx+2] - imageData.data[nidx+2]);
          }
        }
      }
      
      return avgDiff / 24; // Normalize by max possible difference (255) and number of comparisons (8 pixels * 3 channels)
    }

    async function processTexture(blob, options) {
      return new Promise((resolve) => {
        const img = new Image();
        img.src = URL.createObjectURL(blob);
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          
          // Create another canvas for original image (for comparison)
          const originalCanvas = document.createElement('canvas');
          const originalCtx = originalCanvas.getContext('2d');
          originalCanvas.width = img.width;
          originalCanvas.height = img.height;
          originalCtx.drawImage(img, 0, 0);
          
          // Extract values from options
          const {
            targetHue,
            satAdjust,
            brightAdjust,
            contrastAdjust,
            vibranceAmount,
            preservationAmount,
            colorMode,
            thresholdValue,
            noiseReduction
          } = options;
          
          // First pass: analyze image to get color statistics
          let colorStats = { totalPixels: 0, coloredPixels: 0, avgLuminance: 0 };
          
          for (let i = 0; i < data.length; i += 4) {
            const alpha = data[i + 3];
            if (alpha < 10) continue; // Skip transparent pixels
            
            colorStats.totalPixels++;
            const [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);
            if (s > 0.1) colorStats.coloredPixels++;
            colorStats.avgLuminance += l;
          }
          
          if (colorStats.totalPixels > 0) {
            colorStats.avgLuminance /= colorStats.totalPixels;
            colorStats.colorRatio = colorStats.coloredPixels / colorStats.totalPixels;
          }
          
          const threshold = thresholdValue / 100;
          const preservationFactor = preservationAmount / 100;
          
          // Second pass: process pixels
          for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
              const i = (y * canvas.width + x) * 4;
              const alpha = data[i + 3];
              
              if (alpha < 10) continue; // Skip transparent pixels
              
              // Get original color
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              
              // Convert to HSL for main adjustments
              const [h, s, l] = rgbToHsl(r, g, b);
              
              // Apply color mode logic
              let newH = h;
              let newS = s;
              let newL = l;
              
              // Determine if pixel should be recolored based on thresholds
              const colorfulness = s; // Saturation represents colorfulness
              let shouldRecolor = colorfulness > threshold;
              
              // Check noise level if noise reduction is active
              if (noiseReduction > 0) {
                const pixelNoise = getPixelNoise(imageData, x, y, canvas.width);
                const noiseThreshold = noiseReduction / 100;
                if (pixelNoise > noiseThreshold) {
                  shouldRecolor = shouldRecolor && (colorfulness > threshold + 0.2);
                }
              }
              
              if (shouldRecolor) {
                // Apply color transformations based on mode
                switch(colorMode) {
                  case 'standard':
                    newH = targetHue;
                    break;
                  case 'harmonize':
                    // Shift hue toward target by a percentage
                    const hueDistance = (((targetHue - h + 540) % 360) - 180);
                    newH = (h + hueDistance * (1 - preservationFactor)) % 360;
                    break;
                  case 'accent':
                    // Only modify pixels with certain color characteristics

const isAccentColor = s > 0.4 && l > 0.2 && l < 0.8;
if (isAccentColor) {
  newH = targetHue;
} else {
  shouldRecolor = false;
}
break;
case 'tint':
  // Apply a tint overlay that preserves detail
  newH = targetHue;
  newS = Math.min(1, s * 0.7 + 0.3);
  break;
}

// Apply adjustments to saturation and lightness
if (shouldRecolor) {
  // Apply saturation adjustment
  newS = adjustSaturation(newS, satAdjust);
  
  // Apply brightness adjustment
  newL = adjustBrightness(newL, brightAdjust);
  
  // Apply preservation factor (blend between original and new color)
  if (preservationFactor > 0) {
    newH = h * preservationFactor + newH * (1 - preservationFactor);
    newS = s * preservationFactor + newS * (1 - preservationFactor);
    newL = l * preservationFactor + newL * (1 - preservationFactor);
  }
  
  // Convert back to RGB
  let [newR, newG, newB] = hslToRgb(newH, newS, newL);
  
  // Apply contrast adjustment if needed
  if (contrastAdjust !== 0) {
    newR = Math.round(255 * adjustContrast(newR / 255, contrastAdjust));
    newG = Math.round(255 * adjustContrast(newG / 255, contrastAdjust));
    newB = Math.round(255 * adjustContrast(newB / 255, contrastAdjust));
  }
  
  // Apply vibrance if needed
  if (vibranceAmount > 0) {
    [newR, newG, newB] = applyVibrance(newR, newG, newB, vibranceAmount);
  }
  
  // Update pixel data
  data[i] = newR;
  data[i + 1] = newG;
  data[i + 2] = newB;
}
}
}

// Put the modified data back to the canvas
ctx.putImageData(imageData, 0, 0);

// Return both original and modified canvases
resolve({
  original: originalCanvas,
  modified: canvas,
  originalURL: originalCanvas.toDataURL(),
  modifiedURL: canvas.toDataURL()
});
};
});
}

// Handles the form submission to process the texture pack
form.addEventListener("submit", async function(e) {
  e.preventDefault();
  
  if (!packInput.files || !packInput.files[0]) {
    alert("Please select a resource pack file first.");
    return;
  }
  
  // Show processing UI
  status.textContent = "Processing texture pack...";
  statusIcon.textContent = "üîÑ";
  downloadLink.style.display = "none";
  
  const packFile = packInput.files[0];
  const jszip = new JSZip();
  
  try {
    // Extract the uploaded zip file
    const zip = await jszip.loadAsync(packFile);
    const totalFiles = Object.keys(zip.files).length;
    let processedFiles = 0;
    
    // Create a new zip file for the output
    const outputZip = new JSZip();
    
    // Get selected options
    const targetHueStr = huePicker.value;
    const targetHueRgb = hexToRgb(targetHueStr);
    const [targetHue] = rgbToHsl(targetHueRgb[0], targetHueRgb[1], targetHueRgb[2]);
    
    const options = {
      targetHue: targetHue,
      satAdjust: parseInt(saturationSlider.value),
      brightAdjust: parseInt(brightnessSlider.value),
      contrastAdjust: parseInt(contrastSlider.value),
      vibranceAmount: parseInt(vibranceSlider.value),
      preservationAmount: parseInt(preservationSlider.value),
      colorMode: colorShiftMode.value,
      thresholdValue: parseInt(colorThreshold.value),
      noiseReduction: parseInt(noiseLevel.value)
    };
    
    // Get selected texture categories
    const selectedCategories = {
      items: document.getElementById("modifyItems").checked,
      food: document.getElementById("modifyFood").checked,
      blocks: document.getElementById("modifyBlocks").checked,
      ores: document.getElementById("modifyOres").checked,
      swords: document.getElementById("modifySwords").checked,
      tools: document.getElementById("modifyTools").checked,
      bows: document.getElementById("modifyBows").checked,
      armor: document.getElementById("modifyArmor").checked,
      shields: document.getElementById("modifyShields").checked,
      ui: document.getElementById("modifyUI").checked,
      hotbar: document.getElementById("modifyHotbar").checked,
      inventory: document.getElementById("modifyInventory").checked,
      particles: document.getElementById("modifyParticles").checked,
      enchanted: document.getElementById("modifyEnchanted").checked,
      potions: document.getElementById("modifyPotions").checked,
      entities: document.getElementById("modifyEntities").checked
    };
    
    // Preview sample textures
    const previewItems = {
      items: ["diamond", "emerald", "gold_ingot", "iron_ingot", "redstone", "apple", "clock"],
      tools: ["diamond_sword", "diamond_pickaxe", "diamond_axe", "bow", "shield", "iron_helmet"],
      ui: ["inventory", "hotbar", "experience_bar", "icons", "widgets"],
      special: ["potion_overlay", "enchanted_item_glint", "particles/flame"]
    };
    
    // Clear preview grids
    itemsPreviewGrid.innerHTML = "";
    toolsPreviewGrid.innerHTML = "";
    uiPreviewGrid.innerHTML = "";
    specialPreviewGrid.innerHTML = "";
    
    // Helper function to determine if a file should be processed
    function shouldProcessFile(filename) {
      // Basic patterns to match different texture types
      const patterns = {
        items: /item\/|items\/|textures\/items\//,
        food: /food|apple|bread|carrot|potato|beetroot|cookie|beef|porkchop|fish|melon|berries/,
        blocks: /block\/|blocks\/|textures\/blocks\//,
        ores: /ore|diamond|emerald|gold|iron|lapis|redstone|quartz|coal|netherite/,
        swords: /sword/,
        tools: /pickaxe|axe|shovel|hoe|fishing_rod/,
        bows: /bow|crossbow/,
        armor: /helmet|chestplate|leggings|boots/,
        shields: /shield/,
        ui: /gui\/|container\/|menu\/|hud\/|inventory|crafting/,
        hotbar: /hotbar|selected|widgets/,
        inventory: /inventory/,
        particles: /particle|effect|bubble|flame|smoke|splash/,
        enchanted: /enchanted|glint|glow/,
        potions: /potion|bottle|brew/,
        entities: /entity\/|mob\/|character\/|player\//
      };
      
      // Check if file matches any selected category
      for (const [category, isSelected] of Object.entries(selectedCategories)) {
        if (isSelected && patterns[category] && patterns[category].test(filename)) {
          return true;
        }
      }
      
      return false;
    }
    
    // Helper function to convert hex color to RGB
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
      ];
    }
    
    // Process each file in the zip
    const filePromises = [];
    
    zip.forEach((relativePath, zipEntry) => {
      if (zipEntry.dir) {
        // Add directories directly to the output
        outputZip.folder(relativePath);
        return;
      }
      
      // Process only PNG files
      if (relativePath.toLowerCase().endsWith('.png')) {
        if (shouldProcessFile(relativePath)) {
          // Process this texture
          filePromises.push(async () => {
            try {
              const blob = await zipEntry.async('blob');
              
              // Process the texture
              const result = await processTexture(blob, options);
              
              // Add the modified texture to the output zip
              const modifiedBlob = await canvasToBlob(result.modified);
              outputZip.file(relativePath, modifiedBlob);
              
              // Add to preview if this is a preview item
              addToPreviewIfNeeded(relativePath, result);
              
              // Update progress
              processedFiles++;
              const progress = Math.round((processedFiles / totalFiles) * 100);
              progressBar.value = progress;
              progressPercentage.textContent = `${progress}%`;
            } catch (err) {
              console.error(`Error processing ${relativePath}:`, err);
              // Add original file to output in case of error
              const originalBlob = await zipEntry.async('blob');
              outputZip.file(relativePath, originalBlob);
            }
          });
        } else {
          // Add non-processed files directly to output
          filePromises.push(async () => {
            const blob = await zipEntry.async('blob');
            outputZip.file(relativePath, blob);
            
            // Update progress
            processedFiles++;
            const progress = Math.round((processedFiles / totalFiles) * 100);
            progressBar.value = progress;
            progressPercentage.textContent = `${progress}%`;
          });
        }
      } else {
        // For non-PNG files, just copy to output
        filePromises.push(async () => {
          const blob = await zipEntry.async('blob');
          outputZip.file(relativePath, blob);
          
          // Update progress
          processedFiles++;
          const progress = Math.round((processedFiles / totalFiles) * 100);
          progressBar.value = progress;
          progressPercentage.textContent = `${progress}%`;
        });
      }
    });
    
    // Process files in batches to avoid memory issues
    const batchSize = 10;
    for (let i = 0; i < filePromises.length; i += batchSize) {
      const batch = filePromises.slice(i, i + batchSize);
      await Promise.all(batch.map(fn => fn()));
    }
    
    // Generate the output zip file
    const content = await outputZip.generateAsync({
      type: 'blob',
      compression: 'DEFLATE',
      compressionOptions: { level: 6 }
    });
    
    // Create download link
    const url = URL.createObjectURL(content);
    downloadLink.href = url;
    downloadLink.style.display = "inline-flex";
    
    // Update status
    status.textContent = "Pack ready for download!";
    statusIcon.textContent = "‚úÖ";
    
  } catch (error) {
    console.error("Error processing pack:", error);
    status.textContent = "Error processing pack. Please try again.";
    statusIcon.textContent = "‚ùå";
  }
});

// Helper function to convert canvas to blob
function canvasToBlob(canvas) {
  return new Promise((resolve) => {
    canvas.toBlob(resolve, 'image/png');
  });
}

// Helper function to add textures to preview panels
function addToPreviewIfNeeded(path, result) {
  // Check if this texture should be added to preview
  for (const [category, items] of Object.entries(previewItems)) {
    for (const item of items) {
      if (path.toLowerCase().includes(item.toLowerCase())) {
        const previewGrid = document.getElementById(`${category}PreviewGrid`);
        
        // Create preview container
        const container = document.createElement('div');
        container.className = 'preview-item-container';
        if (sideBySideCheckbox.checked) {
          container.classList.add('side-by-side');
        }
        
        // Original image
        const origDiv = document.createElement('div');
        origDiv.className = 'preview-item';
        const origImg = document.createElement('img');
        origImg.src = result.originalURL;
        origImg.className = 'preview-image';
        origImg.style.width = `${64 * currentZoom / 100}px`;
        origImg.style.height = `${64 * currentZoom / 100}px`;
        const origLabel = document.createElement('div');
        origLabel.className = 'preview-label';
        origLabel.textContent = 'Original';
        origDiv.appendChild(origImg);
        origDiv.appendChild(origLabel);
        
        // Modified image
        const modDiv = document.createElement('div');
        modDiv.className = 'preview-item';
        const modImg = document.createElement('img');
        modImg.src = result.modifiedURL;
        modImg.className = 'preview-image';
        modImg.style.width = `${64 * currentZoom / 100}px`;
        modImg.style.height = `${64 * currentZoom / 100}px`;
        const modLabel = document.createElement('div');
        modLabel.className = 'preview-label';
        modLabel.textContent = 'Modified';
        modDiv.appendChild(modImg);
        modDiv.appendChild(modLabel);
        
        // Add name label
        const nameLabel = document.createElement('div');
        nameLabel.className = 'preview-name';
        
        // Extract name from path
        const nameParts = path.split('/');
        const fileName = nameParts[nameParts.length - 1].replace('.png', '');
        nameLabel.textContent = fileName;
        
        // Add everything to container
        container.appendChild(origDiv);
        container.appendChild(modDiv);
        container.appendChild(nameLabel);
        previewGrid.appendChild(container);
        
        // Break after finding a match
        break;
      }
    }
  }
}

// Style additions that would normally be in a CSS file
document.head.insertAdjacentHTML('beforeend', `
<style>
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #f0f0f0;
  margin: 0;
  padding: 0;
  color: #333;
}

.main-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.header {
  text-align: center;
  margin-bottom: 30px;
}

.header h1 {
  font-size: 36px;
  margin-bottom: 5px;
  color: #2c3e50;
}

.subtitle {
  font-size: 18px;
  color: #7f8c8d;
}

.content-container {
  background-color: #fff;
  border-radius: 10px;
  padding: 30px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  font-weight: bold;
  color: #34495e;
}

.file-upload-container {
  border: 2px dashed #3498db;
  border-radius: 8px;
  padding: 20px;
  text-align: center;
  margin-bottom: 30px;
  position: relative;
}

.file-upload-label {
  display: inline-block;
  background-color: #3498db;
  color: white;
  padding: 12px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-weight: bold;
  transition: background-color 0.3s;
}

.file-upload-label:hover {
  background-color: #2980b9;
}

.file-upload-label .icon {
  margin-right: 8px;
}

#packInput {
  position: absolute;
  left: -9999px;
}

.selected-file {
  display: block;
  margin-top: 10px;
  font-style: italic;
  color: #7f8c8d;
}

.options-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  margin-bottom: 30px;
}

.option-card {
  background-color: #f9f9f9;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.option-card h3 {
  margin-top: 0;
  margin-bottom: 20px;
  color: #2c3e50;
  border-bottom: 1px solid #e0e0e0;
  padding-bottom: 10px;
}

.slider-container {
  display: flex;
  align-items: center;
}

.slider-container input[type="range"] {
  flex: 1;
  margin-right: 10px;
}

.slider-container span {
  min-width: 40px;
  text-align: right;
  font-weight: bold;
  color: #7f8c8d;
}

input[type="range"] {
  -webkit-appearance: none;
  width: 100%;
  height: 8px;
  border-radius: 4px;
  background: #e0e0e0;
  outline: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #3498db;
  cursor: pointer;
}

input[type="color"] {
  width: 50px;
  height: 40px;
  border: none;
  border-radius: 4px;
  background: none;
  cursor: pointer;
}

.styled-select {
  width: 100%;
  padding: 10px;
  border-radius: 5px;
  border: 1px solid #e0e0e0;
  background-color: white;
  font-size: 16px;
  color: #34495e;
}

.checkbox-card h4 {
  margin-top: 15px;
  margin-bottom: 10px;
  color: #34495e;
}

.checkbox-section {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
}

.checkbox-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.checkbox-group label {
  display: flex;
  align-items: center;
  font-weight: normal;
  margin-bottom: 0;
}

.checkbox-group input[type="checkbox"] {
  margin-right: 8px;
}

.action-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background-color: #2ecc71;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 12px 20px;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: background-color 0.3s;
  text-decoration: none;
}

.action-button:hover {
  background-color: #27ae60;
}

.button-icon {
  margin-right: 8px;
  font-size: 18px;
}

.download-button {
  background-color: #9b59b6;
  display: none;
  margin-top: 15px;
}

.download-button:hover {
  background-color: #8e44ad;
}

.progress-section {
  margin-top: 30px;
  text-align: center;
}

.status-container {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 15px;
  gap: 10px;
}

#status {
  font-size: 18px;
  font-weight: bold;
  color: #34495e;
}

.status-icon {
  font-size: 24px;
}

.progress-container {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
}

progress {
  flex: 1;
  height: 12px;
  border-radius: 6px;
  margin-right: 10px;
}

progress::-webkit-progress-bar {
  background-color: #f0f0f0;
  border-radius: 6px;
}

progress::-webkit-progress-value {
  background-color: #3498db;
  border-radius: 6px;
}

#progressPercentage {
  font-weight: bold;
  color: #3498db;
  width: 50px;
  text-align: right;
}

#previewContainer {
  margin-top: 40px;
}

#previewContainer h3 {
  text-align: center;
  margin-bottom: 20px;
  color: #2c3e50;
}

.preview-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.preview-tabs {
  display: flex;
  gap: 5px;
}

.tab-button {
  padding: 8px 15px;
  background-color: #f0f0f0;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-weight: bold;
  color: #7f8c8d;
  transition: all 0.3s;
}

.tab-button.active {
  background-color: #3498db;
  color: white;
}

.preview-zoom {
  display: flex;
  align-items: center;
  gap: 5px;
}

.zoom-button {
  background-color: #f0f0f0;
  border: none;
  border-radius: 3px;
  width: 30px;
  height: 30px;
  font-size: 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #34495e;
}

#zoomLevel {
  font-weight: bold;
  width: 50px;
  text-align: center;
}

.preview-comparison {
  text-align: center;
  margin-bottom: 15px;
}

.comparison-option label {
  display: inline-flex;
  align-items: center;
  cursor: pointer;
}

.comparison-option input {
  margin-right: 5px;
}

.preview-panel {
  display: none;
  margin-top: 15px;
}

.preview-panel.active {
  display: block;
}

.preview-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 20px;
}

.preview-item-container {
  background-color: #f9f9f9;
  border-radius: 8px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  align-items: center;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.preview-item-container.side-by-side {
  flex-direction: row;
  justify-content: center;
  flex-wrap: wrap;
  gap: 20px;
}

.preview-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-bottom: 10px;
}

.preview-image {
  border: 1px solid #e0e0e0;
  background-color: #fff;
  image-rendering: pixelated;
  width: 64px;
  height: 64px;
}

.preview-label {
  margin-top: 5px;
  font-size: 12px;
  color: #7f8c8d;
}

.preview-name {
  margin-top: 5px;
  font-weight: bold;
  color: #34495e;
  text-align: center;
}

.color-presets {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
}

.preset-button {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  border: 2px solid #fff;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  transition: transform 0.2s, box-shadow 0.2s;
}

.preset-button:hover {
  transform: scale(1.1);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

@media (max-width: 768px) {
  .options-container {
    grid-template-columns: 1fr;
  }
  
  .checkbox-section {
    grid-template-columns: 1fr;
  }
  
  .preview-grid {
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  }
}
</style>
`);
