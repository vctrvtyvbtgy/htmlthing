<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Minecraft Texture Recolor</title>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
  <div class="page-wrapper">
    <div class="sidebar">
      <div class="logo-container">
        <div class="logo">
          <i class="fas fa-cube"></i>
        </div>
        <h2>TEXTURA</h2>
      </div>
      <div class="nav-links">
        <a href="#" data-tab="recolor-tab" class="active"><i class="fas fa-palette"></i> Recolor</a>
        <a href="#" data-tab="textures-tab"><i class="fas fa-layer-group"></i> Textures</a>
        <a href="#" data-tab="designs-tab"><i class="fas fa-paint-brush"></i> Designs</a>
        <a href="#" data-tab="settings-tab"><i class="fas fa-cog"></i> Settings</a>
      </div>
    </div>
    
    <div class="main-content">
      <header>
        <h1>TEXTURE <span>RECOLOR STUDIO</span></h1>
        <div class="header-accent"></div>
      </header>
      
      <div class="container">
        <!-- Recolor Tab -->
        <div class="tab-content active" id="recolor-tab">
          <div class="tool-panel">
            <form id="textureForm">
              <div class="form-group">
                <label for="packInput">SELECT RESOURCE PACK</label>
                <div class="custom-file-input">
                  <input type="file" id="packInput" accept=".zip" required />
                  <div class="file-input-label">
                    <i class="fas fa-upload"></i>
                    <span>CHOOSE FILE</span>
                  </div>
                </div>
              </div>

              <div class="form-group">
                <label>COLOR MODE</label>
                <div class="radio-group">
                  <label class="radio-option">
                    <input type="radio" name="colorMode" value="solid" checked>
                    <span>Solid Color</span>
                  </label>
                  <label class="radio-option">
                    <input type="radio" name="colorMode" value="gradient">
                    <span>Gradient</span>
                  </label>
                </div>
              </div>

              <div class="form-group" id="solidColorGroup">
                <label for="huePicker">TARGET HUE</label>
                <div class="color-picker-container">
                  <input type="color" id="huePicker" value="#ff00ff" />
                  <span class="color-indicator"></span>
                </div>
              </div>

              <div class="form-group hidden" id="gradientGroup">
                <label>GRADIENT COLORS</label>
                <div class="gradient-pickers">
                  <div class="color-picker-container">
                    <input type="color" id="gradientStart" value="#ff0000" />
                    <span class="color-indicator"></span>
                  </div>
                  <div class="gradient-separator">
                    <i class="fas fa-arrow-right"></i>
                  </div>
                  <div class="color-picker-container">
                    <input type="color" id="gradientEnd" value="#0000ff" />
                    <span class="color-indicator"></span>
                  </div>
                </div>
                <div class="gradient-preview"></div>
              </div>

              <button type="submit" class="action-button">
                <span class="button-text">TRANSFORM</span>
                <i class="fas fa-arrow-right"></i>
              </button>
            </form>

            <div class="progress-section">
              <div class="status-container">
                <div id="status">STATUS: READY</div>
                <progress id="progressBar" value="0" max="100"></progress>
              </div>
              <a id="downloadLink" download="ModifiedPack.zip">
                <i class="fas fa-download"></i>
                <span>DOWNLOAD MODIFIED PACK</span>
              </a>
            </div>
          </div>
        </div>

        <!-- Textures Tab -->
        <div class="tab-content" id="textures-tab">
          <div class="tool-panel">
            <div class="section-header">
              <h3>TEXTURE PREVIEW</h3>
              <div class="section-line"></div>
            </div>
            <div class="texture-controls">
              <div class="texture-counter">
                <span id="textureCount">0</span> textures selected
              </div>
              <button id="clearAll" class="control-button">
                <i class="fas fa-trash"></i> CLEAR ALL
              </button>
            </div>
            <div id="previewGrid" class="texture-preview-grid"></div>
            <div class="empty-state" id="emptyTextureState">
              <i class="fas fa-cubes"></i>
              <p>No textures loaded. Select a resource pack from the Recolor tab.</p>
            </div>
          </div>
        </div>

        <!-- Designs Tab -->
        <div class="tab-content" id="designs-tab">
          <div class="tool-panel">
            <div class="section-header">
              <h3>SAVED DESIGNS</h3>
              <div class="section-line"></div>
            </div>
            <div class="empty-state">
              <i class="fas fa-paint-brush"></i>
              <p>No saved designs yet. Create and save your first design from the Recolor tab.</p>
            </div>
          </div>
        </div>

        <!-- Settings Tab -->
        <div class="tab-content" id="settings-tab">
          <div class="tool-panel">
            <div class="section-header">
              <h3>TEXTURE SETTINGS</h3>
              <div class="section-line"></div>
            </div>
            
            <div class="settings-group">
              <h4>TEXTURE CATEGORIES</h4>
              <p class="settings-desc">Select which texture types to include in the recoloring process:</p>
              
              <div class="checkbox-group">
                <label class="checkbox-option">
                  <input type="checkbox" id="includeItems" checked>
                  <span class="checkbox-custom"></span>
                  <span>Items (swords, tools, food)</span>
                </label>
                
                <label class="checkbox-option">
                  <input type="checkbox" id="includeArmor">
                  <span class="checkbox-custom"></span>
                  <span>Armor & Equipment</span>
                </label>
                
                <label class="checkbox-option">
                  <input type="checkbox" id="includeBlocks">
                  <span class="checkbox-custom"></span>
                  <span>Block Items</span>
                </label>
                
                <label class="checkbox-option">
                  <input type="checkbox" id="includeEntities">
                  <span class="checkbox-custom"></span>
                  <span>Entity Textures</span>
                </label>
                
                <label class="checkbox-option">
                  <input type="checkbox" id="includeGUI">
                  <span class="checkbox-custom"></span>
                  <span>GUI Elements</span>
                </label>
              </div>
            </div>
            
            <div class="settings-group">
              <h4>PROCESSING OPTIONS</h4>
              
              <div class="setting-row">
                <label for="saturationAdjust">Saturation Adjustment</label>
                <div class="slider-control">
                  <input type="range" id="saturationAdjust" min="0" max="200" value="100">
                  <span class="slider-value">100%</span>
                </div>
              </div>
              
              <div class="setting-row">
                <label for="brightnessAdjust">Brightness Adjustment</label>
                <div class="slider-control">
                  <input type="range" id="brightnessAdjust" min="0" max="200" value="100">
                  <span class="slider-value">100%</span>
                </div>
              </div>
              
              <div class="checkbox-option">
                <input type="checkbox" id="preserveShading" checked>
                <span class="checkbox-custom"></span>
                <span>Preserve Original Shading</span>
              </div>
              
              <div class="checkbox-option">
                <input type="checkbox" id="ignoreGrayscale" checked>
                <span class="checkbox-custom"></span>
                <span>Skip Grayscale Textures</span>
              </div>
            </div>
            
            <div class="settings-group">
              <h4>PERFORMANCE</h4>
              
              <div class="setting-row">
                <label for="processingSpeed">Processing Speed</label>
                <div class="slider-control">
                  <input type="range" id="processingSpeed" min="1" max="5" value="3">
                  <span class="slider-value">Normal</span>
                </div>
              </div>
              
              <div class="checkbox-option">
                <input type="checkbox" id="enablePreview" checked>
                <span class="checkbox-custom"></span>
                <span>Generate Previews (may be slower)</span>
              </div>
            </div>
            
            <button id="saveSettings" class="action-button">
              <span class="button-text">SAVE SETTINGS</span>
              <i class="fas fa-check"></i>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Tab Navigation
    document.querySelectorAll('.nav-links a').forEach(tab => {
      tab.addEventListener('click', function(e) {
        e.preventDefault();
        
        // Remove active class from all tabs
        document.querySelectorAll('.nav-links a').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
        
        // Add active class to clicked tab
        this.classList.add('active');
        
        // Show corresponding content
        const tabId = this.getAttribute('data-tab');
        document.getElementById(tabId).classList.add('active');
      });
    });

    // Form elements
    const form = document.getElementById("textureForm");
    const status = document.getElementById("status");
    const previewGrid = document.getElementById("previewGrid");
    const progressBar = document.getElementById("progressBar");
    const downloadLink = document.getElementById("downloadLink");
    const textureCount = document.getElementById("textureCount");
    const clearAllBtn = document.getElementById("clearAll");
    const emptyTextureState = document.getElementById("emptyTextureState");
    
    // Color mode toggle
    document.querySelectorAll('input[name="colorMode"]').forEach(radio => {
      radio.addEventListener('change', function() {
        if (this.value === 'solid') {
          document.getElementById('solidColorGroup').classList.remove('hidden');
          document.getElementById('gradientGroup').classList.add('hidden');
        } else {
          document.getElementById('solidColorGroup').classList.add('hidden');
          document.getElementById('gradientGroup').classList.remove('hidden');
        }
      });
    });

    // Settings sliders
    document.querySelectorAll('.slider-control input').forEach(slider => {
      slider.addEventListener('input', function() {
        const valueDisplay = this.parentElement.querySelector('.slider-value');
        
        if (this.id === 'processingSpeed') {
          const speedLabels = ['Very Slow', 'Slow', 'Normal', 'Fast', 'Very Fast'];
          valueDisplay.textContent = speedLabels[this.value - 1];
        } else {
          valueDisplay.textContent = this.value + '%';
        }
      });
    });

    // Initialize settings button
    document.getElementById('saveSettings').addEventListener('click', function() {
      // Flash notification
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.innerHTML = '<i class="fas fa-check-circle"></i> Settings saved successfully!';
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.classList.add('show');
        setTimeout(() => {
          notification.classList.remove('show');
          setTimeout(() => {
            notification.remove();
          }, 300);
        }, 2000);
      }, 10);
    });

    // Clear All button
    clearAllBtn.addEventListener('click', function() {
      previewGrid.innerHTML = '';
      textureCount.textContent = '0';
      selectedTextures = [];
      emptyTextureState.style.display = 'flex';
    });

    // Color functions
    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }

      return [h * 360, s, l];
    }

    function hslToRgb(h, s, l) {
      h /= 360;
      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;

        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }

      return [r * 255, g * 255, b * 255];
    }

    // Gradient color calculation
    function getGradientColorAtPosition(pos, startColor, endColor) {
      // Convert hex colors to RGB
      const startR = parseInt(startColor.slice(1, 3), 16);
      const startG = parseInt(startColor.slice(3, 5), 16);
      const startB = parseInt(startColor.slice(5, 7), 16);
      
      const endR = parseInt(endColor.slice(1, 3), 16);
      const endG = parseInt(endColor.slice(3, 5), 16);
      const endB = parseInt(endColor.slice(5, 7), 16);
      
      // Linear interpolation
      const r = Math.round(startR + (endR - startR) * pos);
      const g = Math.round(startG + (endG - startG) * pos);
      const b = Math.round(startB + (endB - startB) * pos);
      
      return [r, g, b];
    }

    async function shiftHue(blob, targetHue, isGradient = false, gradientStart = '#ff0000', gradientEnd = '#0000ff') {
      return new Promise((resolve) => {
        const img = new Image();
        img.src = URL.createObjectURL(blob);
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          // Get adjustments from settings
          const satAdjust = parseInt(document.getElementById('saturationAdjust').value) / 100;
          const brightAdjust = parseInt(document.getElementById('brightnessAdjust').value) / 100;
          const preserveShading = document.getElementById('preserveShading').checked;
          const ignoreGrayscale = document.getElementById('ignoreGrayscale').checked;

          for (let i = 0; i < data.length; i += 4) {
            const alpha = data[i + 3];
            if (alpha < 10) continue; // Skip transparent pixels
            
            // Get original HSL values
            const [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);
            
            // Skip grayscale pixels if option is checked
            if (ignoreGrayscale && s < 0.1) continue;
            
            let newH, newS, newL;
            
            if (isGradient) {
              // For gradient, use the vertical position to determine color
              const y = Math.floor((i / 4) / canvas.width);
              const position = y / canvas.height;
              
              // Get color from gradient
              const [r, g, b] = getGradientColorAtPosition(position, gradientStart, gradientEnd);
              const [gradientH] = rgbToHsl(r, g, b);
              
              newH = gradientH;
            } else {
              // For solid color, use target hue
              newH = targetHue;
            }
            
            // Apply saturation adjustment
            newS = s * satAdjust;
            if (newS > 1) newS = 1;
            
            // Apply brightness adjustment keeping original shading
            if (preserveShading) {
              newL = l * brightAdjust;
              if (newL > 1) newL = 1;
            } else {
              newL = l;
            }
            
            // Convert back to RGB
            const [r, g, b] = hslToRgb(newH, newS, newL);
            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
          }

          ctx.putImageData(imageData, 0, 0);
          canvas.toBlob(resolve, 'image/png');
        };
      });
    }

    async function isBlockItem(path, zip) {
      // Skip check if blocks are disabled
      if (!document.getElementById('includeBlocks').checked) return false;
      
      const modelPath = path.replace("textures/item/", "models/item/").replace(".png", ".json");
      try {
        const modelFile = await zip.file(modelPath)?.async("string");
        if (!modelFile) return false;
        const model = JSON.parse(modelFile);
        return model.parent?.includes("block") || false;
      } catch {
        return false;
      }
    }
    
    function shouldProcessTexture(path) {
      const includeItems = document.getElementById('includeItems').checked;
      const includeArmor = document.getElementById('includeArmor').checked;
      const includeEntities = document.getElementById('includeEntities').checked;
      const includeGUI = document.getElementById('includeGUI').checked;
      
      if (path.includes("textures/item/") && includeItems) return true;
      if (path.includes("textures/models/armor") && includeArmor) return true;
      if (path.includes("textures/entity") && includeEntities) return true;
      if ((path.includes("textures/gui") || path.includes("container")) && includeGUI) return true;
      
      return false;
    }

    // Array to keep track of selected textures
    let selectedTextures = [];
    
    // Function to update texture preview and selection
    function updateTexturePreview(path, blob) {
      const imgURL = URL.createObjectURL(blob);
      const imgContainer = document.createElement("div");
      imgContainer.className = "preview-image-container";
      imgContainer.dataset.path = path;
      
      const img = document.createElement("img");
      img.src = imgURL;
      img.alt = path.split("/").pop();
      img.title = path;
      img.className = "preview-image";
      
      const removeBtn = document.createElement("div");
      removeBtn.className = "remove-texture";
      removeBtn.innerHTML = '<i class="fas fa-times"></i>';
      
      imgContainer.appendChild(img);
      imgContainer.appendChild(removeBtn);
      previewGrid.appendChild(imgContainer);
      
      selectedTextures.push(path);
      textureCount.textContent = selectedTextures.length;
      emptyTextureState.style.display = 'none';
      
      // Add remove functionality
      removeBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        
        // Remove from selectedTextures array
        const index = selectedTextures.indexOf(path);
        if (index > -1) {
          selectedTextures.splice(index, 1);
        }
        
        // Remove from display
        imgContainer.classList.add('removing');
        setTimeout(() => {
          imgContainer.remove();
          textureCount.textContent = selectedTextures.length;
          
          if (selectedTextures.length === 0) {
            emptyTextureState.style.display = 'flex';
          }
        }, 300);
      });
    }

    // Update gradient preview
    function updateGradientPreview() {
      const start = document.getElementById('gradientStart').value;
      const end = document.getElementById('gradientEnd').value;
      const preview = document.querySelector('.gradient-preview');
      
      preview.style.background = `linear-gradient(to bottom, ${start}, ${end})`;
    }

    // Set up color picker events
    document.getElementById('huePicker').addEventListener('input', function() {
      document.querySelector('#solidColorGroup .color-indicator').style.backgroundColor = this.value;
    });
    
    document.getElementById('gradientStart').addEventListener('input', function() {
      this.nextElementSibling.style.backgroundColor = this.value;
      updateGradientPreview();
    });
    
    document.getElementById('gradientEnd').addEventListener('input', function() {
      this.nextElementSibling.style.backgroundColor = this.value;
      updateGradientPreview();
    });
    
    // Initialize gradient preview
    updateGradientPreview();
    
    // Initialize color indicators
    document.querySelector('#solidColorGroup .color-indicator').style.backgroundColor = document.getElementById('huePicker').value;
    document.querySelectorAll('#gradientGroup .color-indicator')[0].style.backgroundColor = document.getElementById('gradientStart').value;
    document.querySelectorAll('#gradientGroup .color-indicator')[1].style.backgroundColor = document.getElementById('gradientEnd').value;

    // Form submission
    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      const file = document.getElementById("packInput").files[0];
      if (!file) return;
      
      const colorMode = document.querySelector('input[name="colorMode"]:checked').value;
      let targetHue, gradientStart, gradientEnd;
      
      if (colorMode === 'solid') {
        const hueHex = document.getElementById("huePicker").value;
        const r = parseInt(hueHex.slice(1, 3), 16);
        const g = parseInt(hueHex.slice(3, 5), 16);
        const b = parseInt(hueHex.slice(5, 7), 16);
        [targetHue] = rgbToHsl(r, g, b);
      } else {
        gradientStart = document.getElementById("gradientStart").value;
        gradientEnd = document.getElementById("gradientEnd").value;
      }

      status.textContent = "Reading pack...";
      previewGrid.innerHTML = '';
      selectedTextures = [];
      progressBar.value = 0;
      downloadLink.style.display = "none";
      textureCount.textContent = "0";
      emptyTextureState.style.display = 'flex';

      const zip = await JSZip.loadAsync(file);
      const newZip = new JSZip();
      const texturePaths = [];

      for (const relativePath in zip.files) {
        const file = zip.files[relativePath];
        const isBlockTexture = await isBlockItem(relativePath, zip);
        
        if (shouldProcessTexture(relativePath) && !isBlockTexture && relativePath.endsWith(".png")) {
          texturePaths.push(relativePath);
        } else if (!relativePath.endsWith("/")) {
          newZip.file(relativePath, file.async("arraybuffer"));
        }
      }

      // If no textures found
      if (texturePaths.length === 0) {
        status.textContent = "No compatible textures found in pack!";
        return;
      }

      // Get processing speed
      const processingSpeed = parseInt(document.getElementById('processingSpeed').value);
      const generatePreviews = document.getElementById('enablePreview').checked;
      
      // Determine delay between processing textures based on speed setting
      const processingDelays = [100, 50, 20, 5, 1];
      const delay = processingDelays[processingSpeed - 1];

      let completed = 0;
      for (const path of texturePaths) {
        const imgData = await zip.file(path).async("blob");
        
        let modifiedBlob;
        if (colorMode === 'solid') {
          modifiedBlob = await shiftHue(imgData, targetHue);
        } else {
          modifiedBlob = await shiftHue(imgData, 0, true, gradientStart, gradientEnd);
        }

        // Update preview if enabled
        if (generatePreviews) {
          updateTexturePreview(path, modifiedBlob);
        }

        newZip.file(path, modifiedBlob);

        completed++;
        progressBar.value = (completed / texturePaths.length) * 100;
        status.textContent = `PROCESSING: ${completed} OF ${texturePaths.length}`;
        
        // Add delay based on processing speed setting
        await new Promise(r => setTimeout(r, delay));
      }

      // Switch to Textures tab after processing is complete
      document.querySelector('.nav-links a[data-tab="textures-tab"]').click();

      const resultBlob = await newZip.generateAsync({ type: "blob" });
      downloadLink.href = URL.createObjectURL(resultBlob);
      downloadLink.style.display = "flex";
      status.textContent = "COMPLETE! READY FOR DOWNLOAD.";
    });

    // File input styling
    document.querySelector('.file-input-label').addEventListener('click', () => {
      document.getElementById('packInput').click();
    });

    document.getElementById('packInput').addEventListener('change', function() {
      const fileName = this.files[0]?.name || 'No file selected';
      document.querySelector('.file-input-label span').textContent = fileName;
    });
  </script>

  <style>
    * {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: 'Helvetica Neue', Arial, sans-serif;
  background: #111111;
  color: #ffffff;
  height: 100vh;
  overflow: hidden;
  line-height: 1.6;
}

.page-wrapper {
  display: flex;
  height: 100vh;
}

.sidebar {
  width: 250px;
  background: #0a0a0a;
  height: 100%;
  padding: 30px 0;
  box-shadow: 5px 0 15px rgba(0, 0, 0, 0.2);
  position: relative;
  z-index: 10;
}

.logo-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-bottom: 30px;
}

.logo-container img {
  max-width: 80%;
  margin-bottom: 10px;
}

.nav-links {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.nav-links a {
  text-decoration: none;
  color: #ffffff;
  padding: 15px 20px;
  width: 100%;
  text-align: left;
  transition: all 0.2s ease;
  font-weight: 600;
}

.nav-links a:hover {
  background-color: rgba(255, 255, 255, 0.05);
}

.main-content {
  flex-grow: 1;
  overflow-y: auto;
  background: #111111;
  padding: 30px;
}

  </style>
